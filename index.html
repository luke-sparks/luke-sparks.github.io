<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cube Map Generator</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .controls { margin-bottom: 20px; }
        .controls input, button { margin: 5px; padding: 5px; }
        .cube-grid { 
            display: grid; 
            grid-template-columns: repeat(4, 80px); 
            grid-template-rows: repeat(3, 80px); 
            gap: 1px; 
        }
        .face canvas { width: 100%; height: 100%; border: 2px solid red; }
    </style>
</head>
<body>
    <div class="controls">
        <label>Size: <input type="number" id="size" placeholder="128" min="1" max="10000" style="width: 100px;"> miles per side</label>
        <label>Seed: <input type="text" id="seed" placeholder="Random"></label>
        <button onclick="randomSeed()">Random Seed</button>
        <button onclick="generate()">Generate</button>
        <button onclick="switchView()">Toggle View</button>
        <button onclick="downloadAll()">Download All</button>
        <button onclick="downloadCubeNet()">Download Cube Net</button>
        <span id="viewLabel">(Heightmap)</span>
    </div>
    
    <div style="display: flex; gap: 20px;">
        <div>
            <h4>Cube Net</h4>
            <div class="cube-grid">
                <!-- Cross layout: top, left-front-right-back, bottom -->
                <div></div><div class="face"><canvas id="top"></canvas></div><div></div><div></div>
                <div class="face"><canvas id="left"></canvas></div><div class="face"><canvas id="front"></canvas></div><div class="face"><canvas id="right"></canvas></div><div class="face"><canvas id="back"></canvas></div>
                <div></div><div class="face"><canvas id="bottom"></canvas></div><div></div><div></div>
            </div>
            <div style="font-size: 12px; margin-top: 10px; color: #666;">
                Realistic scaling: Islands ~20mi, Continents ~80mi, Rivers ~4mi wide, Lakes ~15mi scale.<br>
                Enhanced water system: Cross-face lake detection (&lt;10% total size). Lakes use special heightmap (4→0, 5→1, 6→2, 7→4, 8→7, 9→10, 10→14).<br>
                Lake adjustment: Lakes set to same height as lowest 4-connected shore, appear lower due to heightmap mapping.<br>
                Enhanced oceans: Deep ocean (10%+ coverage), shallows extend 2-15mi from shore, dramatic depth variation.<br>
                Heightmap values: Ocean(0), Beach(1), Lowlands(2), Hills(3), Highlands(5), Mountains(8), High peaks(11), Snow caps(15).<br>
                Edge continuity is mathematically guaranteed and tested on generation.
            </div>
        </div>
    </div>

    <script>
        let currentView = 'heightmap';
        let currentData = null;
        let currentLayers = null;

        class Noise {
            constructor(seed) {
                this.seed = this.hashSeed(seed || Math.random().toString());
            }
            
            hashSeed(s) {
                let h = 0;
                for (let i = 0; i < s.length; i++) {
                    h = ((h << 5) - h + s.charCodeAt(i)) | 0;
                }
                // Ensure seed has strong impact by using multiple hash iterations
                h = h * 1013904223 + 1664525;
                h = h * 1664525 + 1013904223;
                return Math.abs(h) / 2147483648;
            }
            
            hash(x, y, z) {
                // Strong hash function that amplifies seed differences
                let h = this.seed * 999999999 + x * 374761393 + y * 668265263 + z * 1274126177;
                h = (h ^ (h >>> 13)) * 1274126177;
                h = (h ^ (h >>> 16)) * 1974126343;
                h = (h ^ (h >>> 7)) * 1374761393;
                return (h ^ (h >>> 14)) / 4294967296 + 0.5;
            }
            
            smoothstep(t) { return t * t * (3 - 2 * t); }
            
            noise3D(x, y, z) {
                const ix = Math.floor(x), iy = Math.floor(y), iz = Math.floor(z);
                const fx = x - ix, fy = y - iy, fz = z - iz;
                const sx = this.smoothstep(fx), sy = this.smoothstep(fy), sz = this.smoothstep(fz);
                
                // Get hash values for cube corners
                const c000 = this.hash(ix, iy, iz);
                const c001 = this.hash(ix, iy, iz+1);
                const c010 = this.hash(ix, iy+1, iz);
                const c011 = this.hash(ix, iy+1, iz+1);
                const c100 = this.hash(ix+1, iy, iz);
                const c101 = this.hash(ix+1, iy, iz+1);
                const c110 = this.hash(ix+1, iy+1, iz);
                const c111 = this.hash(ix+1, iy+1, iz+1);
                
                // Trilinear interpolation
                const c00 = c000*(1-sx) + c100*sx;
                const c01 = c001*(1-sx) + c101*sx;
                const c10 = c010*(1-sx) + c110*sx;
                const c11 = c011*(1-sx) + c111*sx;
                
                const c0 = c00*(1-sy) + c10*sy;
                const c1 = c01*(1-sy) + c11*sy;
                
                return c0*(1-sz) + c1*sz;
            }
            
            fbm(x, y, z, octaves = 6) {
                let value = 0, amp = 1, freq = 1, maxValue = 0;
                for (let i = 0; i < octaves; i++) {
                    value += this.noise3D(x * freq, y * freq, z * freq) * amp;
                    maxValue += amp;
                    amp *= 0.5;
                    freq *= 2;
                }
                return value / maxValue;
            }
        }

        function getCubeCoords(face, u, v) {
            // Convert texture coordinates [0,1] to cube coordinates
            // Using standard cube mapping with perfect edge continuity
            const s = u * 2 - 1;  // [-1, 1]
            const t = v * 2 - 1;  // [-1, 1]
            
            let x, y, z;
            
            // Standard OpenGL cube mapping convention for perfect edge alignment
            switch(face) {
                case 'front':  // +Z face
                    x = s; y = -t; z = 1;
                    break;
                case 'back':   // -Z face  
                    x = -s; y = -t; z = -1;
                    break;
                case 'right':  // +X face
                    x = 1; y = -t; z = -s;
                    break;
                case 'left':   // -X face
                    x = -1; y = -t; z = s;
                    break;
                case 'top':    // +Y face
                    x = s; y = 1; z = t;
                    break;
                case 'bottom': // -Y face
                    x = s; y = -1; z = -t;
                    break;
            }
            
            // Normalize to unit sphere for seamless noise sampling across edges
            const len = Math.sqrt(x*x + y*y + z*z);
            return { x: x/len, y: y/len, z: z/len };
        }

        function enhanceOceanDepths(allFaceData, size) {
            const adjacency = getCubeFaceAdjacency();
            const shallowMinRange = 2;
            const shallowMaxRange = 15;
            const searchRadius = Math.min(shallowMaxRange + 5, size / 4);
            
            // Create global distance maps and queue for all faces
            const globalDistanceMap = {};
            const queue = [];
            
            // Initialize distance maps for all faces and find land pixels
            Object.keys(allFaceData).forEach(face => {
                const { isWater } = allFaceData[face];
                globalDistanceMap[face] = new Float32Array(size * size);
                
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const idx = y * size + x;
                        
                        if (isWater[idx]) {
                            globalDistanceMap[face][idx] = Infinity;
                        } else {
                            globalDistanceMap[face][idx] = 0;
                            queue.push({face, x, y, dist: 0});
                        }
                    }
                }
            });
            
            if (queue.length === 0) return;
            
            // Cross-face breadth-first search for distance calculation
            let queuePos = 0;
            while (queuePos < queue.length) {
                const {face, x, y, dist} = queue[queuePos++];
                
                // Check 8-connected neighbors (including cross-face)
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        
                        const nx = x + dx;
                        const ny = y + dy;
                        const newDist = dist + Math.sqrt(dx * dx + dy * dy);
                        
                        // Handle within-face neighbors
                        if (nx >= 0 && nx < size && ny >= 0 && ny < size) {
                            const nIdx = ny * size + nx;
                            const faceData = allFaceData[face];
                            
                            if (faceData.isWater[nIdx] && newDist < globalDistanceMap[face][nIdx]) {
                                globalDistanceMap[face][nIdx] = newDist;
                                if (newDist <= searchRadius) {
                                    queue.push({face, x: nx, y: ny, dist: newDist});
                                }
                            }
                        } else {
                            // Handle cross-face neighbors
                            let adjacentFace = null;
                            let adjacentX = -1, adjacentY = -1;
                            
                            if (nx < 0 && adjacency[face].left) {
                                const [adjFace, adjEdge] = adjacency[face].left;
                                const adjPixels = getEdgePixels(size, adjEdge);
                                if (y < adjPixels.length) {
                                    adjacentFace = adjFace;
                                    adjacentX = adjPixels[y].x;
                                    adjacentY = adjPixels[y].y;
                                }
                            } else if (nx >= size && adjacency[face].right) {
                                const [adjFace, adjEdge] = adjacency[face].right;
                                const adjPixels = getEdgePixels(size, adjEdge);
                                if (y < adjPixels.length) {
                                    adjacentFace = adjFace;
                                    adjacentX = adjPixels[y].x;
                                    adjacentY = adjPixels[y].y;
                                }
                            } else if (ny < 0 && adjacency[face].top) {
                                const [adjFace, adjEdge] = adjacency[face].top;
                                const adjPixels = getEdgePixels(size, adjEdge);
                                if (x < adjPixels.length) {
                                    adjacentFace = adjFace;
                                    adjacentX = adjPixels[x].x;
                                    adjacentY = adjPixels[x].y;
                                }
                            } else if (ny >= size && adjacency[face].bottom) {
                                const [adjFace, adjEdge] = adjacency[face].bottom;
                                const adjPixels = getEdgePixels(size, adjEdge);
                                if (x < adjPixels.length) {
                                    adjacentFace = adjFace;
                                    adjacentX = adjPixels[x].x;
                                    adjacentY = adjPixels[x].y;
                                }
                            }
                            
                            if (adjacentFace && allFaceData[adjacentFace]) {
                                const adjIdx = adjacentY * size + adjacentX;
                                const adjFaceData = allFaceData[adjacentFace];
                                
                                if (adjFaceData.isWater[adjIdx] && newDist < globalDistanceMap[adjacentFace][adjIdx]) {
                                    globalDistanceMap[adjacentFace][adjIdx] = newDist;
                                    if (newDist <= searchRadius) {
                                        queue.push({face: adjacentFace, x: adjacentX, y: adjacentY, dist: newDist});
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Apply depth levels for each face
            Object.keys(allFaceData).forEach(face => {
                const { waterData, isWater } = allFaceData[face];
                const distanceMap = globalDistanceMap[face];
                
                for (let i = 0; i < size * size; i++) {
                    if (isWater[i]) {
                        const distance = distanceMap[i];
                        let depthLevel;
                        
                        if (distance <= shallowMinRange) {
                            depthLevel = 3;
                        } else if (distance <= shallowMaxRange) {
                            const ratio = (distance - shallowMinRange) / (shallowMaxRange - shallowMinRange);
                            depthLevel = ratio < 0.5 ? 3 : 2;
                        } else {
                            depthLevel = 1;
                        }
                        
                        waterData[i] = depthLevel;
                    }
                }
            });
        }

        function getCubeFaceAdjacency() {
            // Define how cube faces connect to each other
            // Each edge is defined as [face, edge] where edge is 0=top, 1=right, 2=bottom, 3=left
            return {
                'front': {
                    top: ['top', 2],      // Front top -> Top bottom
                    right: ['right', 3],  // Front right -> Right left  
                    bottom: ['bottom', 0], // Front bottom -> Bottom top
                    left: ['left', 1]     // Front left -> Left right
                },
                'back': {
                    top: ['top', 0],      // Back top -> Top top
                    right: ['left', 3],   // Back right -> Left left
                    bottom: ['bottom', 2], // Back bottom -> Bottom bottom  
                    left: ['right', 1]    // Back left -> Right right
                },
                'right': {
                    top: ['top', 1],      // Right top -> Top right
                    right: ['back', 3],   // Right right -> Back left
                    bottom: ['bottom', 1], // Right bottom -> Bottom right
                    left: ['front', 1]    // Right left -> Front right
                },
                'left': {
                    top: ['top', 3],      // Left top -> Top left
                    right: ['front', 3],  // Left right -> Front left
                    bottom: ['bottom', 3], // Left bottom -> Bottom left
                    left: ['back', 1]     // Left left -> Back right
                },
                'top': {
                    top: ['back', 0],     // Top top -> Back top
                    right: ['right', 0],  // Top right -> Right top
                    bottom: ['front', 0], // Top bottom -> Front top
                    left: ['left', 0]     // Top left -> Left top
                },
                'bottom': {
                    top: ['front', 2],    // Bottom top -> Front bottom
                    right: ['right', 2],  // Bottom right -> Right bottom
                    bottom: ['back', 2],  // Bottom bottom -> Back bottom
                    left: ['left', 2]     // Bottom left -> Left bottom
                }
            };
        }

        function getEdgePixels(size, edge) {
            // Get pixel coordinates for each edge of a face
            const pixels = [];
            switch(edge) {
                case 0: // top edge
                    for (let x = 0; x < size; x++) pixels.push({x, y: 0});
                    break;
                case 1: // right edge  
                    for (let y = 0; y < size; y++) pixels.push({x: size-1, y});
                    break;
                case 2: // bottom edge
                    for (let x = 0; x < size; x++) pixels.push({x, y: size-1});
                    break;
                case 3: // left edge
                    for (let y = 0; y < size; y++) pixels.push({x: 0, y});
                    break;
            }
            return pixels;
        }

        function adjustLakeHeights(allFaceData, size) {
            const adjacency = getCubeFaceAdjacency();
            const maxLakeSize = Math.max(20, size * size * 0.1);
            const globalVisited = {};
            const waterBodies = [];
            
            // Initialize global visited tracking
            Object.keys(allFaceData).forEach(face => {
                globalVisited[face] = new Uint8Array(size * size);
            });
            
            // Find all connected water bodies across faces
            for (const startFace of Object.keys(allFaceData)) {
                const { isWater } = allFaceData[startFace];
                
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const idx = y * size + x;
                        
                        if (isWater[idx] && !globalVisited[startFace][idx]) {
                            const waterBody = [];
                            const queue = [{face: startFace, x, y}];
                            
                            // Cross-face flood fill
                            while (queue.length > 0) {
                                const {face, x: cx, y: cy} = queue.shift();
                                const cidx = cy * size + cx;
                                
                                if (globalVisited[face][cidx]) continue;
                                globalVisited[face][cidx] = 1;
                                waterBody.push({face, x: cx, y: cy, idx: cidx});
                                
                                const faceData = allFaceData[face];
                                
                                // Check neighbors within same face
                                for (const [dx, dy] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
                                    const nx = cx + dx;
                                    const ny = cy + dy;
                                    
                                    if (nx >= 0 && nx < size && ny >= 0 && ny < size) {
                                        const nidx = ny * size + nx;
                                        if (faceData.isWater[nidx] && !globalVisited[face][nidx]) {
                                            queue.push({face, x: nx, y: ny});
                                        }
                                    } else {
                                        // Check cross-face connections
                                        let adjacentFace = null;
                                        let adjacentX = -1, adjacentY = -1;
                                        
                                        if (nx < 0 && adjacency[face].left) {
                                            const [adjFace, adjEdge] = adjacency[face].left;
                                            const adjPixels = getEdgePixels(size, adjEdge);
                                            if (cy < adjPixels.length) {
                                                adjacentFace = adjFace;
                                                adjacentX = adjPixels[cy].x;
                                                adjacentY = adjPixels[cy].y;
                                            }
                                        } else if (nx >= size && adjacency[face].right) {
                                            const [adjFace, adjEdge] = adjacency[face].right;
                                            const adjPixels = getEdgePixels(size, adjEdge);
                                            if (cy < adjPixels.length) {
                                                adjacentFace = adjFace;
                                                adjacentX = adjPixels[cy].x;
                                                adjacentY = adjPixels[cy].y;
                                            }
                                        } else if (ny < 0 && adjacency[face].top) {
                                            const [adjFace, adjEdge] = adjacency[face].top;
                                            const adjPixels = getEdgePixels(size, adjEdge);
                                            if (cx < adjPixels.length) {
                                                adjacentFace = adjFace;
                                                adjacentX = adjPixels[cx].x;
                                                adjacentY = adjPixels[cx].y;
                                            }
                                        } else if (ny >= size && adjacency[face].bottom) {
                                            const [adjFace, adjEdge] = adjacency[face].bottom;
                                            const adjPixels = getEdgePixels(size, adjEdge);
                                            if (cx < adjPixels.length) {
                                                adjacentFace = adjFace;
                                                adjacentX = adjPixels[cx].x;
                                                adjacentY = adjPixels[cx].y;
                                            }
                                        }
                                        
                                        if (adjacentFace && allFaceData[adjacentFace]) {
                                            const adjIdx = adjacentY * size + adjacentX;
                                            if (allFaceData[adjacentFace].isWater[adjIdx] && !globalVisited[adjacentFace][adjIdx]) {
                                                queue.push({face: adjacentFace, x: adjacentX, y: adjacentY});
                                            }
                                        }
                                    }
                                }
                            }
                            
                            const isLake = waterBody.length <= maxLakeSize;
                            waterBodies.push({waterBody, isLake});
                        }
                    }
                }
            }
            
            // Adjust lake heights
            for (const {waterBody, isLake} of waterBodies) {
                if (!isLake) continue;
                
                let minSurroundingHeight = 11;
                
                // Find minimum surrounding land height across all faces (4-connected only)
                for (const {face, x, y} of waterBody) {
                    const faceData = allFaceData[face];
                    
                    // Check only 4-connected neighbors (cardinal directions) for shore
                    for (const [dx, dy] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        // Handle within-face neighbors
                        if (nx >= 0 && nx < size && ny >= 0 && ny < size) {
                            const nidx = ny * size + nx;
                            if (!faceData.isWater[nidx]) {
                                minSurroundingHeight = Math.min(minSurroundingHeight, faceData.landData[nidx]);
                            }
                        } else {
                            // Handle cross-face neighbors (4-connected only)
                            let adjacentFace = null;
                            let adjacentX = -1, adjacentY = -1;
                            
                            if (nx < 0 && adjacency[face].left) {
                                const [adjFace, adjEdge] = adjacency[face].left;
                                const adjPixels = getEdgePixels(size, adjEdge);
                                if (y < adjPixels.length) {
                                    adjacentFace = adjFace;
                                    adjacentX = adjPixels[y].x;
                                    adjacentY = adjPixels[y].y;
                                }
                            } else if (nx >= size && adjacency[face].right) {
                                const [adjFace, adjEdge] = adjacency[face].right;
                                const adjPixels = getEdgePixels(size, adjEdge);
                                if (y < adjPixels.length) {
                                    adjacentFace = adjFace;
                                    adjacentX = adjPixels[y].x;
                                    adjacentY = adjPixels[y].y;
                                }
                            } else if (ny < 0 && adjacency[face].top) {
                                const [adjFace, adjEdge] = adjacency[face].top;
                                const adjPixels = getEdgePixels(size, adjEdge);
                                if (x < adjPixels.length) {
                                    adjacentFace = adjFace;
                                    adjacentX = adjPixels[x].x;
                                    adjacentY = adjPixels[x].y;
                                }
                            } else if (ny >= size && adjacency[face].bottom) {
                                const [adjFace, adjEdge] = adjacency[face].bottom;
                                const adjPixels = getEdgePixels(size, adjEdge);
                                if (x < adjPixels.length) {
                                    adjacentFace = adjFace;
                                    adjacentX = adjPixels[x].x;
                                    adjacentY = adjPixels[x].y;
                                }
                            }
                            
                            if (adjacentFace && allFaceData[adjacentFace]) {
                                const adjIdx = adjacentY * size + adjacentX;
                                if (!allFaceData[adjacentFace].isWater[adjIdx]) {
                                    minSurroundingHeight = Math.min(minSurroundingHeight, allFaceData[adjacentFace].landData[adjIdx]);
                                }
                            }
                        }
                    }
                }
                
                if (minSurroundingHeight < 11) {
                    const lakeHeight = Math.max(4, minSurroundingHeight);
                    for (const {face, idx} of waterBody) {
                        allFaceData[face].waterData[idx] = lakeHeight;
                    }
                }
            }
        }

        function getBiome(heightLevel, temperature, moisture) {
            // Exactly 10 colors based on height levels 1-10
            // Enhanced ocean depths: Level 1 (deep), Level 2 (medium), Level 3 (shallow)
            
            const colors = [
                null, // Index 0 unused
                [5, 15, 60],    // Level 1: Deep ocean (very dark blue)
                [15, 35, 90],   // Level 2: Medium ocean (medium blue)
                [30, 60, 130],  // Level 3: Shallow ocean (lighter blue)
                [220, 200, 160], // Level 4: Beach/coastal (sandy)
                [120, 180, 80],  // Level 5: Lowlands/plains (green)
                [100, 150, 70],  // Level 6: Hills (darker green)
                [140, 120, 80],  // Level 7: Highlands (brown-green)
                [160, 140, 100], // Level 8: Mountains (brown)
                [180, 160, 140], // Level 9: High mountains (gray-brown)
                [240, 240, 250]  // Level 10: Snow peaks (white)
            ];
            
            // Return the exact color for this height level
            return colors[heightLevel] || [0, 0, 0];
        }

        function generateFace(face, size, noise) {
            const heightData = new Float32Array(size * size);
            const biomeData = new Uint8ClampedArray(size * size * 4);
            
            // Separate water and land data
            const waterData = new Float32Array(size * size);
            const landData = new Float32Array(size * size);
            const isWater = new Uint8Array(size * size);
            
            // Store individual layers for debugging/visualization
            const layers = {};
            
            // Scale-aware terrain generation (1 pixel = 1 mile)
            const milesPerSide = size;
            
            // Calculate feature scales based on desired real-world sizes
            const continentScale = milesPerSide / 80;
            const islandScale = milesPerSide / 20;
            const mountainScale = milesPerSide / 40;
            const riverScale = milesPerSide / 4;
            const hillScale = milesPerSide / 8;
            const detailScale = milesPerSide / 2;
            const tectonicScale = milesPerSide / 60;
            const ridgeScale = milesPerSide / 30;
            const coastalScale = milesPerSide / 6;
            const climateScale = milesPerSide / 100;
            const precipScale = milesPerSide / 80;
            const lakeScale = milesPerSide / 15;
            
            // Pre-allocate all layers
            const continentsLayer = new Float32Array(size * size);
            const islandsLayer = new Float32Array(size * size);
            const mountainsLayer = new Float32Array(size * size);
            const riversLayer = new Float32Array(size * size);
            const hillsLayer = new Float32Array(size * size);
            const detailsLayer = new Float32Array(size * size);
            const tectonicsLayer = new Float32Array(size * size);
            const lakesLayer = new Float32Array(size * size);
            
            // Pre-calculate coordinates and noise in single pass
            const coords = new Array(size * size);
            const checkRadius = Math.max(1, Math.floor(size / 100));
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const idx = y * size + x;
                    const u = x / (size - 1);
                    const v = y / (size - 1);
                    
                    // Get 3D coordinates ensuring perfect edge continuity
                    coords[idx] = getCubeCoords(face, u, v);
                    const coord = coords[idx];
                    
                    // Generate all noise layers in single pass
                    const continents = noise.fbm(coord.x * continentScale, coord.y * continentScale, coord.z * continentScale, 3) * 0.7;
                    continentsLayer[idx] = Math.max(0, Math.min(1, continents + 0.5));
                    
                    const islands = noise.fbm(coord.x * islandScale + 100, coord.y * islandScale + 100, coord.z * islandScale + 100, 4) * 0.4;
                    islandsLayer[idx] = Math.max(0, Math.min(1, islands + 0.5));
                    
                    const mountains = noise.fbm(coord.x * mountainScale + 200, coord.y * mountainScale + 200, coord.z * mountainScale + 200, 3) * 0.5;
                    mountainsLayer[idx] = Math.max(0, Math.min(1, mountains + 0.5));
                    
                    const rivers = noise.fbm(coord.x * riverScale + 300, coord.y * riverScale + 300, coord.z * riverScale + 300, 2);
                    riversLayer[idx] = Math.max(0, Math.min(1, Math.abs(rivers)));
                    
                    const hills = noise.fbm(coord.x * hillScale + 400, coord.y * hillScale + 400, coord.z * hillScale + 400, 4) * 0.2;
                    hillsLayer[idx] = Math.max(0, Math.min(1, hills + 0.5));
                    
                    const details = noise.fbm(coord.x * detailScale + 500, coord.y * detailScale + 500, coord.z * detailScale + 500, 3) * 0.1;
                    detailsLayer[idx] = Math.max(0, Math.min(1, details + 0.5));
                    
                    const tectonics = noise.fbm(coord.x * tectonicScale + 700, coord.y * tectonicScale + 700, coord.z * tectonicScale + 700, 2);
                    tectonicsLayer[idx] = Math.max(0, Math.min(1, tectonics + 0.5));
                    
                    const lakes = noise.fbm(coord.x * lakeScale + 600, coord.y * lakeScale + 600, coord.z * lakeScale + 600, 3);
                    lakesLayer[idx] = Math.max(0, Math.min(1, lakes + 0.5));
                    
                    // Generate land height first
                    let landHeight = continents * 0.35 + islands * 0.2 + mountains * 0.3 + hills * 0.1 + details * 0.05;
                    
                    // Enhanced mountain building for land
                    if (tectonics > 0.5 && landHeight > 0.25) {
                        const mountainBoost = (tectonics - 0.5) * 1.5;
                        landHeight += mountainBoost;
                    }
                    
                    if (tectonics > 0.75 && landHeight > 0.4) {
                        const superPeaks = (tectonics - 0.75) * 2.0;
                        landHeight += superPeaks;
                    }
                    
                    // Mountain ridge enhancement
                    const ridges = noise.fbm(coord.x * ridgeScale + 1100, coord.y * ridgeScale + 1100, coord.z * ridgeScale + 1100, 2);
                    if (ridges > 0.6 && landHeight > 0.5) {
                        landHeight += (ridges - 0.6) * 1.2;
                    }
                    
                    // Coastal erosion and beaches
                    if (milesPerSide >= 20) {
                        const coastal = noise.fbm(coord.x * coastalScale + 800, coord.y * coastalScale + 800, coord.z * coastalScale + 800, 2) * 0.05;
                        if (landHeight > 0.15 && landHeight < 0.4) {
                            landHeight += coastal;
                        }
                    }
                    
                    landHeight = Math.max(0, Math.min(1, landHeight));
                    
                    // Determine if this is water or land
                    let isWaterPixel = landHeight <= 0.3;
                    
                    // Add lake generation for enclosed areas
                    if (!isWaterPixel && landHeight > 0.4 && lakes > 0.7) {
                        isWaterPixel = true;
                    }
                    
                    // River carving (creates water)
                    if (!isWaterPixel && landHeight > 0.25 && milesPerSide >= 10) {
                        const riverCarving = Math.abs(rivers);
                        if (riverCarving < 0.1) {
                            isWaterPixel = true;
                        }
                    }
                    
                    isWater[idx] = isWaterPixel ? 1 : 0;
                    
                    if (isWaterPixel) {
                        // Generate water depths (will be adjusted later for lakes)
                        waterData[idx] = landHeight <= 0.1 ? 1 : (landHeight <= 0.2 ? 2 : 3);
                        landData[idx] = 0;
                    } else {
                        // Quantize land height to discrete levels (4-10)
                        let quantizedHeight = Math.floor(((landHeight - 0.3) / 0.7) * 7) + 4;
                        quantizedHeight = Math.max(4, Math.min(10, quantizedHeight));
                        
                        // Minimize large sand areas - optimized coastal check
                        if (quantizedHeight === 4) {
                            let nearWater = false;
                            
                            // Efficient spiral search pattern
                            for (let r = 1; r <= checkRadius && !nearWater; r++) {
                                for (let angle = 0; angle < 8 && !nearWater; angle++) {
                                    const dx = Math.round(r * Math.cos(angle * Math.PI / 4));
                                    const dy = Math.round(r * Math.sin(angle * Math.PI / 4));
                                    
                                    const checkX = Math.max(0, Math.min(size-1, x + dx));
                                    const checkY = Math.max(0, Math.min(size-1, y + dy));
                                    
                                    if (checkX !== x || checkY !== y) {
                                        const checkU = checkX / (size - 1);
                                        const checkV = checkY / (size - 1);
                                        const checkCoords = getCubeCoords(face, checkU, checkV);
                                        
                                        // Quick height estimation using fewer octaves
                                        const checkContinents = noise.fbm(checkCoords.x * continentScale, checkCoords.y * continentScale, checkCoords.z * continentScale, 2) * 0.7;
                                        const checkIslands = noise.fbm(checkCoords.x * islandScale + 100, checkCoords.y * islandScale + 100, checkCoords.z * islandScale + 100, 2) * 0.4;
                                        
                                        let checkHeight = checkContinents * 0.6 + checkIslands * 0.4;
                                        checkHeight = Math.max(0, Math.min(1, checkHeight));
                                        
                                        if (checkHeight <= 0.3) {
                                            nearWater = true;
                                        }
                                    }
                                }
                            }
                            
                            if (!nearWater) {
                                quantizedHeight = 5;
                            }
                        }
                        
                        waterData[idx] = 0;
                        landData[idx] = quantizedHeight;
                    }
                }
            }
            
            // Post-process ocean for more dramatic depth variation
            // Note: Ocean depth enhancement is now done as a separate pass after all faces are generated
            
            // Combine water and land data into final height data
            for (let i = 0; i < size * size; i++) {
                if (isWater[i]) {
                    heightData[i] = waterData[i] / 10;
                } else {
                    heightData[i] = landData[i] / 10;
                }
            }
            
            // Generate biomes in final pass
            for (let i = 0; i < size * size; i++) {
                const coord = coords[i];
                const finalHeight = Math.round(heightData[i] * 10);
                
                // Use isWater array to determine biome type, not just height
                if (isWater[i]) {
                    // Water biome - always use water colors (1-3) regardless of actual height
                    const actualWaterHeight = Math.round(waterData[i]);
                    let waterColorLevel;
                    
                    // Map water heights to water color levels (1-3 only)
                    if (actualWaterHeight <= 3) {
                        waterColorLevel = actualWaterHeight; // Use as-is for ocean depths
                    } else {
                        // For lakes at higher elevations, use shallow water color
                        waterColorLevel = 3;
                    }
                    
                    const biome = getBiome(waterColorLevel, 0, 1);
                    
                    const biomeIdx = i * 4;
                    biomeData[biomeIdx] = biome[0];
                    biomeData[biomeIdx + 1] = biome[1];
                    biomeData[biomeIdx + 2] = biome[2];
                    biomeData[biomeIdx + 3] = 255;
                } else {
                    // Land biome - generate climate for land
                    let latitude = Math.abs(coord.y);
                    let baseTemp = 1.0 - latitude * 0.8;
                    const elevationCooling = Math.max(0, (finalHeight/10) - 0.3) * 1.0;
                    const tempNoise = noise.fbm(coord.x * climateScale + 900, coord.y * climateScale + 900, coord.z * climateScale + 900, 3) * 0.3;
                    const temperature = Math.max(0, Math.min(1, baseTemp - elevationCooling + tempNoise));
                    
                    const precipitation = noise.fbm(coord.x * precipScale + 1000, coord.y * precipScale + 1000, coord.z * precipScale + 1000, 3);
                    const oceanInfluence = Math.max(0, 0.5 - Math.max(0, (finalHeight/10) - 0.2) * 2);
                    const moisture = Math.max(0, Math.min(1, precipitation * 0.6 + oceanInfluence * 0.3));
                    
                    const biome = getBiome(finalHeight, temperature, moisture);
                    
                    const biomeIdx = i * 4;
                    biomeData[biomeIdx] = biome[0];
                    biomeData[biomeIdx + 1] = biome[1];
                    biomeData[biomeIdx + 2] = biome[2];
                    biomeData[biomeIdx + 3] = 255;
                }
            }
            
            // Store layers
            layers.continents = continentsLayer;
            layers.islands = islandsLayer;
            layers.mountains = mountainsLayer;
            layers.rivers = riversLayer;
            layers.hills = hillsLayer;
            layers.details = detailsLayer;
            layers.tectonics = tectonicsLayer;
            layers.lakes = lakesLayer;
            layers.water = waterData;
            layers.land = landData;
            layers.isWater = isWater;
            
            return { heightData, biomeData, layers };
        }

        function render(canvas, heightData, biomeData, size, view, isWater, waterData) {
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(size, size);
            const data = imageData.data;
            
            if (view === 'heightmap') {
                // Height value remapping for land: 1-3→0, 4→1, 5→2, 6→3, 7→5, 8→8, 9→11, 10→15
                const landHeightMapping = {
                    1: 0, 2: 0, 3: 0,  // Ocean depths → 0
                    4: 1,              // Beach → 1
                    5: 2,              // Lowlands → 2
                    6: 3,              // Hills → 3
                    7: 5,              // Highlands → 5
                    8: 8,              // Mountains → 8
                    9: 11,             // High mountains → 11
                    10: 15             // Snow peaks → 15
                };
                
                // Separate height mapping for lakes: 4→0, 5→1, 6→2, 7→4, 8→7, 9→10, 10→14
                const lakeHeightMapping = {
                    1: 0, 2: 0, 3: 0,  // Ocean depths → 0 (shouldn't be used for lakes)
                    4: 0,              // Lake at beach level → 0
                    5: 1,              // Lake at lowland level → 1
                    6: 2,              // Lake at hill level → 2
                    7: 4,              // Lake at highland level → 4
                    8: 7,              // Lake at mountain level → 7
                    9: 10,             // Lake at high mountain level → 10
                    10: 14             // Lake at snow peak level → 14
                };
                
                for (let i = 0; i < heightData.length; i++) {
                    // Convert quantized height (0.1-1.0) back to discrete levels
                    const heightLevel = Math.round(heightData[i] * 10);
                    
                    let remappedValue;
                    if (isWater && isWater[i]) {
                        const waterHeight = Math.round(waterData[i]);
                        if (waterHeight <= 3) {
                            // Ocean/rivers: map to 0
                            remappedValue = 0;
                        } else {
                            // Lakes: use lake-specific height mapping
                            remappedValue = lakeHeightMapping[waterHeight] || 0;
                        }
                    } else {
                        // Use normal height mapping for land
                        remappedValue = landHeightMapping[heightLevel] || 0;
                    }
                    
                    const colorValue = remappedValue * 8; // Height value * 8 for RGB
                    
                    data[i * 4] = colorValue;     // R
                    data[i * 4 + 1] = colorValue; // G
                    data[i * 4 + 2] = colorValue; // B
                    data[i * 4 + 3] = 255;       // A
                }
            } else {
                data.set(biomeData);
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        function randomSeed() {
            const seed = Math.random().toString(36).substr(2, 9);
            document.getElementById('seed').value = seed;
        }

        function testEdgeContinuity(size, seed) {
            const noise = new Noise(seed);
            const faces = ['front', 'back', 'left', 'right', 'top', 'bottom'];
            const data = {};
            
            // Generate all faces
            faces.forEach(face => {
                data[face] = generateFace(face, size, noise);
            });
            
            let errors = 0;
            const tolerance = 0.001;
            
            // Check edge continuity between adjacent faces
            const adjacencyTests = [
                () => {
                    for (let i = 0; i < size; i++) {
                        const frontEdge = data.front.heightData[i * size + (size - 1)];
                        const rightEdge = data.right.heightData[i * size + 0];
                        if (Math.abs(frontEdge - rightEdge) > tolerance) {
                            errors++;
                        }
                    }
                },
                () => {
                    for (let i = 0; i < size; i++) {
                        const frontEdge = data.front.heightData[0 * size + i];
                        const topEdge = data.top.heightData[(size - 1) * size + i];
                        if (Math.abs(frontEdge - topEdge) > tolerance) {
                            errors++;
                        }
                    }
                },
                () => {
                    for (let i = 0; i < size; i++) {
                        const rightEdge = data.right.heightData[0 * size + i];
                        const topEdge = data.top.heightData[i * size + (size - 1)];
                        if (Math.abs(rightEdge - topEdge) > tolerance) {
                            errors++;
                        }
                    }
                }
            ];
            
            adjacencyTests.forEach(test => test());
            return errors === 0;
        }

        function generate() {
            let size = parseInt(document.getElementById('size').value);
            
            if (isNaN(size) || size < 1) {
                size = 64;
                document.getElementById('size').value = 64;
            }
            
            const seedInput = document.getElementById('seed').value.trim();
            const seed = seedInput || Math.random().toString(36).substr(2, 9);
            
            document.getElementById('seed').value = seed;
            const noise = new Noise(seed);
            
            if (size <= 128) {
                testEdgeContinuity(Math.min(32, size), seed);
            }
            
            const faces = ['front', 'back', 'left', 'right', 'top', 'bottom'];
            currentData = {};
            const allFaceData = {};
            
            // First pass: Generate all face terrain data
            faces.forEach(face => {
                const data = generateFace(face, size, noise);
                currentData[face] = data;
                
                // Store face data for cross-face lake detection
                allFaceData[face] = {
                    waterData: data.layers.water,
                    landData: data.layers.land,
                    isWater: data.layers.isWater
                };
                
                // Store layers from front face for layer visualization
                if (face === 'front') {
                    currentLayers = data.layers;
                }
            });
            
            // Second pass: Enhance ocean depths across all faces, then adjust lake heights
            enhanceOceanDepths(allFaceData, size);
            adjustLakeHeights(allFaceData, size);
            
            // Third pass: Update final heightData and render
            faces.forEach(face => {
                const data = currentData[face];
                const faceData = allFaceData[face];
                
                // Update final height data with adjusted lake heights
                for (let i = 0; i < size * size; i++) {
                    if (faceData.isWater[i]) {
                        data.heightData[i] = faceData.waterData[i] / 10;
                    } else {
                        data.heightData[i] = faceData.landData[i] / 10;
                    }
                }
                
                // Update layers with adjusted data
                data.layers.water = faceData.waterData;
                data.layers.land = faceData.landData;
                data.layers.isWater = faceData.isWater;
                
                // Regenerate biome data with correct lake classifications
                const biomeData = new Uint8ClampedArray(size * size * 4);
                for (let i = 0; i < size * size; i++) {
                    if (faceData.isWater[i]) {
                        const actualWaterHeight = Math.round(faceData.waterData[i]);
                        let waterColorLevel;
                        
                        if (actualWaterHeight <= 3) {
                            waterColorLevel = actualWaterHeight;
                        } else {
                            waterColorLevel = 3;
                        }
                        
                        const biome = getBiome(waterColorLevel, 0, 1);
                        
                        const biomeIdx = i * 4;
                        biomeData[biomeIdx] = biome[0];
                        biomeData[biomeIdx + 1] = biome[1];
                        biomeData[biomeIdx + 2] = biome[2];
                        biomeData[biomeIdx + 3] = 255;
                    } else {
                        const biomeIdx = i * 4;
                        biomeData[biomeIdx] = data.biomeData[biomeIdx];
                        biomeData[biomeIdx + 1] = data.biomeData[biomeIdx + 1];
                        biomeData[biomeIdx + 2] = data.biomeData[biomeIdx + 2];
                        biomeData[biomeIdx + 3] = data.biomeData[biomeIdx + 3];
                    }
                }
                
                data.biomeData = biomeData;
                
                const canvas = document.getElementById(face);
                render(canvas, data.heightData, data.biomeData, size, currentView, faceData.isWater, faceData.waterData);
            });
        }

        function switchView() {
            currentView = currentView === 'heightmap' ? 'biome' : 'heightmap';
            document.getElementById('viewLabel').textContent = `(${currentView === 'heightmap' ? 'Heightmap' : 'Biome'})`;
            
            if (currentData) {
                const size = parseInt(document.getElementById('size').value);
                Object.keys(currentData).forEach(face => {
                    const canvas = document.getElementById(face);
                    const data = currentData[face];
                    // Use the stored layers data which contains the adjusted water heights
                    render(canvas, data.heightData, data.biomeData, size, currentView, data.layers.isWater, data.layers.water);
                });
            }
        }

        function downloadCubeNet() {
            if (!currentData) {
                alert('Please generate a map first!');
                return;
            }
            
            const size = parseInt(document.getElementById('size').value) || 128;
            const timestamp = new Date().toISOString().slice(0, 16).replace(/[:-]/g, '');
            const seedValue = document.getElementById('seed').value || 'random';
            const sizeValue = document.getElementById('size').value || '128';
            
            // Create combined canvas for cube net (4x3 grid)
            const combinedCanvas = document.createElement('canvas');
            const borderWidth = 2; // Match the red border width
            const faceSize = size;
            const totalWidth = (faceSize + borderWidth) * 4 + borderWidth;
            const totalHeight = (faceSize + borderWidth) * 3 + borderWidth;
            
            combinedCanvas.width = totalWidth;
            combinedCanvas.height = totalHeight;
            const ctx = combinedCanvas.getContext('2d');
            
            // Fill background with black
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, totalWidth, totalHeight);
            
            // Draw red grid lines
            ctx.strokeStyle = 'red';
            ctx.lineWidth = borderWidth;
            
            // Vertical lines
            for (let i = 0; i <= 4; i++) {
                const x = i * (faceSize + borderWidth) + borderWidth / 2;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, totalHeight);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let i = 0; i <= 3; i++) {
                const y = i * (faceSize + borderWidth) + borderWidth / 2;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(totalWidth, y);
                ctx.stroke();
            }
            
            // Define face positions in the cube net (4x3 grid)
            const facePositions = {
                'top': { x: 1, y: 0 },
                'left': { x: 0, y: 1 },
                'front': { x: 1, y: 1 },
                'right': { x: 2, y: 1 },
                'back': { x: 3, y: 1 },
                'bottom': { x: 1, y: 2 }
            };
            
            // Draw each face at its position
            Object.keys(facePositions).forEach(face => {
                const canvas = document.getElementById(face);
                if (canvas) {
                    const pos = facePositions[face];
                    const x = pos.x * (faceSize + borderWidth) + borderWidth;
                    const y = pos.y * (faceSize + borderWidth) + borderWidth;
                    
                    ctx.drawImage(canvas, x, y, faceSize, faceSize);
                }
            });
            
            // Download the combined image
            try {
                const link = document.createElement('a');
                link.style.display = 'none';
                link.download = `cubenet_${currentView}_${sizeValue}mi_${seedValue}_${timestamp}.png`;
                link.href = combinedCanvas.toDataURL();
                link.click();
            } catch (error) {
                console.error('Failed to download cube net:', error);
            }
        }

        function downloadAll() {
            if (!currentData) {
                alert('Please generate a map first!');
                return;
            }

            const timestamp = new Date().toISOString().slice(0, 16).replace(/[:-]/g, '');
            const seedValue = document.getElementById('seed').value || 'random';
            const sizeValue = document.getElementById('size').value || '128';
            
            Object.keys(currentData).forEach(face => {
                const canvas = document.getElementById(face);
                const link = document.createElement('a');
                link.download = `${face}_${currentView}_${sizeValue}mi_${seedValue}_${timestamp}.png`;
                link.href = canvas.toDataURL();
                link.click();
            });
        }

        // Generate initial map with test seed to verify edge continuity  
        document.getElementById('size').value = '80';
        document.getElementById('seed').value = 'test123';
        generate();
    </script>
</body>
</html>
