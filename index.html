<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cube Map Generator</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .controls { margin-bottom: 20px; }
        .controls input, button { margin: 5px; padding: 5px; }
        .cube-grid { 
            display: grid; 
            grid-template-columns: repeat(4, 80px); 
            grid-template-rows: repeat(3, 80px); 
            gap: 1px; 
        }
        .face canvas { width: 100%; height: 100%; border: 2px solid red; }
    </style>
</head>
<body>
    <div class="controls">
        <label>Size: <input type="number" id="size" placeholder="128" min="1" max="10000" style="width: 100px;"> miles per side</label>
        <label>Seed: <input type="text" id="seed" placeholder="Random"></label>
        <button onclick="randomSeed()">Random Seed</button>
        <button onclick="generate()">Generate</button>
        <button onclick="switchView()">Toggle View</button>
        <button onclick="downloadAll()">Download All</button>
        <button onclick="downloadCubeNet()">Download Cube Net</button>
        <span id="viewLabel">(Heightmap)</span>
    </div>
    
    <div style="display: flex; gap: 20px;">
        <div>
            <h4>Cube Net</h4>
            <div class="cube-grid">
                <!-- Cross layout: top, left-front-right-back, bottom -->
                <div></div><div class="face"><canvas id="top"></canvas></div><div></div><div></div>
                <div class="face"><canvas id="left"></canvas></div><div class="face"><canvas id="front"></canvas></div><div class="face"><canvas id="right"></canvas></div><div class="face"><canvas id="back"></canvas></div>
                <div></div><div class="face"><canvas id="bottom"></canvas></div><div></div><div></div>
            </div>
            <div style="font-size: 12px; margin-top: 10px; color: #666;">
                Realistic scaling: Islands ~20mi, Continents ~80mi, Rivers ~4mi wide.<br>
                Enhanced oceans: Deep ocean (10%+ coverage), shallows extend 2-15mi from shore, dramatic depth variation.<br>
                Heightmap values: Ocean(0), Beach(1), Lowlands(2), Hills(3), Highlands(5), Mountains(8), High peaks(11), Snow caps(15).<br>
                Edge continuity is mathematically guaranteed and tested on generation.
            </div>
        </div>
    </div>

    <script>
        let currentView = 'heightmap';
        let currentData = null;
        let currentLayers = null;

        class Noise {
            constructor(seed) {
                this.seed = this.hashSeed(seed || Math.random().toString());
            }
            
            hashSeed(s) {
                let h = 0;
                for (let i = 0; i < s.length; i++) {
                    h = ((h << 5) - h + s.charCodeAt(i)) | 0;
                }
                // Ensure seed has strong impact by using multiple hash iterations
                h = h * 1013904223 + 1664525;
                h = h * 1664525 + 1013904223;
                return Math.abs(h) / 2147483648;
            }
            
            hash(x, y, z) {
                // Strong hash function that amplifies seed differences
                let h = this.seed * 999999999 + x * 374761393 + y * 668265263 + z * 1274126177;
                h = (h ^ (h >>> 13)) * 1274126177;
                h = (h ^ (h >>> 16)) * 1974126343;
                h = (h ^ (h >>> 7)) * 1374761393;
                return (h ^ (h >>> 14)) / 4294967296 + 0.5;
            }
            
            smoothstep(t) { return t * t * (3 - 2 * t); }
            
            noise3D(x, y, z) {
                const ix = Math.floor(x), iy = Math.floor(y), iz = Math.floor(z);
                const fx = x - ix, fy = y - iy, fz = z - iz;
                const sx = this.smoothstep(fx), sy = this.smoothstep(fy), sz = this.smoothstep(fz);
                
                // Get hash values for cube corners
                const c000 = this.hash(ix, iy, iz);
                const c001 = this.hash(ix, iy, iz+1);
                const c010 = this.hash(ix, iy+1, iz);
                const c011 = this.hash(ix, iy+1, iz+1);
                const c100 = this.hash(ix+1, iy, iz);
                const c101 = this.hash(ix+1, iy, iz+1);
                const c110 = this.hash(ix+1, iy+1, iz);
                const c111 = this.hash(ix+1, iy+1, iz+1);
                
                // Trilinear interpolation
                const c00 = c000*(1-sx) + c100*sx;
                const c01 = c001*(1-sx) + c101*sx;
                const c10 = c010*(1-sx) + c110*sx;
                const c11 = c011*(1-sx) + c111*sx;
                
                const c0 = c00*(1-sy) + c10*sy;
                const c1 = c01*(1-sy) + c11*sy;
                
                return c0*(1-sz) + c1*sz;
            }
            
            fbm(x, y, z, octaves = 6) {
                let value = 0, amp = 1, freq = 1, maxValue = 0;
                for (let i = 0; i < octaves; i++) {
                    value += this.noise3D(x * freq, y * freq, z * freq) * amp;
                    maxValue += amp;
                    amp *= 0.5;
                    freq *= 2;
                }
                return value / maxValue;
            }
        }

        function getCubeCoords(face, u, v) {
            // Convert texture coordinates [0,1] to cube coordinates
            // Using standard cube mapping with perfect edge continuity
            const s = u * 2 - 1;  // [-1, 1]
            const t = v * 2 - 1;  // [-1, 1]
            
            let x, y, z;
            
            // Standard OpenGL cube mapping convention for perfect edge alignment
            switch(face) {
                case 'front':  // +Z face
                    x = s; y = -t; z = 1;
                    break;
                case 'back':   // -Z face  
                    x = -s; y = -t; z = -1;
                    break;
                case 'right':  // +X face
                    x = 1; y = -t; z = -s;
                    break;
                case 'left':   // -X face
                    x = -1; y = -t; z = s;
                    break;
                case 'top':    // +Y face
                    x = s; y = 1; z = t;
                    break;
                case 'bottom': // -Y face
                    x = s; y = -1; z = -t;
                    break;
            }
            
            // Normalize to unit sphere for seamless noise sampling across edges
            const len = Math.sqrt(x*x + y*y + z*z);
            return { x: x/len, y: y/len, z: z/len };
        }

        function enhanceOceanDepths(heightData, size) {
            // Optimized ocean depth enhancement
            const shallowMinRange = 2;
            const shallowMaxRange = 15;
            const searchRadius = Math.min(shallowMaxRange + 5, size / 4);
            
            // Create distance map using efficient flood-fill algorithm
            const distanceMap = new Float32Array(size * size);
            const oceanMask = new Uint8Array(size * size);
            const queue = [];
            
            // Initialize ocean mask and find land pixels
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const idx = y * size + x;
                    const height = Math.round(heightData[idx] * 10);
                    
                    if (height <= 3) {
                        oceanMask[idx] = 1;
                        distanceMap[idx] = Infinity;
                    } else {
                        oceanMask[idx] = 0;
                        distanceMap[idx] = 0;
                        queue.push({x, y, dist: 0});
                    }
                }
            }
            
            if (queue.length === 0) return; // No land found
            
            // Breadth-first search for distance calculation
            let queuePos = 0;
            while (queuePos < queue.length) {
                const {x, y, dist} = queue[queuePos++];
                
                // Check 8-connected neighbors
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        if (nx >= 0 && nx < size && ny >= 0 && ny < size) {
                            const nIdx = ny * size + nx;
                            const newDist = dist + Math.sqrt(dx * dx + dy * dy);
                            
                            if (oceanMask[nIdx] && newDist < distanceMap[nIdx]) {
                                distanceMap[nIdx] = newDist;
                                if (newDist <= searchRadius) {
                                    queue.push({x: nx, y: ny, dist: newDist});
                                }
                            }
                        }
                    }
                }
            }
            
            // Apply depth levels and count pixels in single pass
            let deepOceanCount = 0;
            let mediumOceanIndices = [];
            
            for (let i = 0; i < size * size; i++) {
                if (oceanMask[i]) {
                    const distance = distanceMap[i];
                    let depthLevel;
                    
                    if (distance <= shallowMinRange) {
                        depthLevel = 3;
                    } else if (distance <= shallowMaxRange) {
                        const ratio = (distance - shallowMinRange) / (shallowMaxRange - shallowMinRange);
                        depthLevel = ratio < 0.5 ? 3 : 2;
                    } else {
                        depthLevel = 1;
                    }
                    
                    heightData[i] = depthLevel / 10;
                    
                    if (depthLevel === 1) {
                        deepOceanCount++;
                    } else if (depthLevel === 2) {
                        mediumOceanIndices.push(i);
                    }
                }
            }
            
            // Ensure at least 10% deep ocean
            const totalOcean = queue.length > 0 ? size * size - queue.length + (size * size - queuePos) : 0;
            const requiredDeepOcean = Math.ceil(totalOcean * 0.1);
            
            if (deepOceanCount < requiredDeepOcean && mediumOceanIndices.length > 0) {
                const toConvert = Math.min(requiredDeepOcean - deepOceanCount, mediumOceanIndices.length);
                for (let i = 0; i < toConvert; i++) {
                    heightData[mediumOceanIndices[i]] = 1 / 10;
                }
            }
        }

        function getBiome(heightLevel, temperature, moisture) {
            // Exactly 10 colors based on height levels 1-10
            // Enhanced ocean depths: Level 1 (deep), Level 2 (medium), Level 3 (shallow)
            
            const colors = [
                null, // Index 0 unused
                [5, 15, 60],    // Level 1: Deep ocean (very dark blue)
                [15, 35, 90],   // Level 2: Medium ocean (medium blue)
                [30, 60, 130],  // Level 3: Shallow ocean (lighter blue)
                [220, 200, 160], // Level 4: Beach/coastal (sandy)
                [120, 180, 80],  // Level 5: Lowlands/plains (green)
                [100, 150, 70],  // Level 6: Hills (darker green)
                [140, 120, 80],  // Level 7: Highlands (brown-green)
                [160, 140, 100], // Level 8: Mountains (brown)
                [180, 160, 140], // Level 9: High mountains (gray-brown)
                [240, 240, 250]  // Level 10: Snow peaks (white)
            ];
            
            // Return the exact color for this height level
            return colors[heightLevel] || [0, 0, 0];
        }

        function generateFace(face, size, noise) {
            const heightData = new Float32Array(size * size);
            const biomeData = new Uint8ClampedArray(size * size * 4);
            
            // Store individual layers for debugging/visualization
            const layers = {};
            
            // Scale-aware terrain generation (1 pixel = 1 mile)
            const milesPerSide = size;
            
            // Calculate feature scales based on desired real-world sizes
            const continentScale = milesPerSide / 80;
            const islandScale = milesPerSide / 20;
            const mountainScale = milesPerSide / 40;
            const riverScale = milesPerSide / 4;
            const hillScale = milesPerSide / 8;
            const detailScale = milesPerSide / 2;
            const tectonicScale = milesPerSide / 60;
            const ridgeScale = milesPerSide / 30;
            const coastalScale = milesPerSide / 6;
            const climateScale = milesPerSide / 100;
            const precipScale = milesPerSide / 80;
            
            // Pre-allocate all layers
            const continentsLayer = new Float32Array(size * size);
            const islandsLayer = new Float32Array(size * size);
            const mountainsLayer = new Float32Array(size * size);
            const riversLayer = new Float32Array(size * size);
            const hillsLayer = new Float32Array(size * size);
            const detailsLayer = new Float32Array(size * size);
            const tectonicsLayer = new Float32Array(size * size);
            
            // Pre-calculate coordinates and noise in single pass
            const coords = new Array(size * size);
            const checkRadius = Math.max(1, Math.floor(size / 100));
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const idx = y * size + x;
                    const u = x / (size - 1);
                    const v = y / (size - 1);
                    
                    // Get 3D coordinates ensuring perfect edge continuity
                    coords[idx] = getCubeCoords(face, u, v);
                    const coord = coords[idx];
                    
                    // Generate all noise layers in single pass
                    const continents = noise.fbm(coord.x * continentScale, coord.y * continentScale, coord.z * continentScale, 3) * 0.7;
                    continentsLayer[idx] = Math.max(0, Math.min(1, continents + 0.5));
                    
                    const islands = noise.fbm(coord.x * islandScale + 100, coord.y * islandScale + 100, coord.z * islandScale + 100, 4) * 0.4;
                    islandsLayer[idx] = Math.max(0, Math.min(1, islands + 0.5));
                    
                    const mountains = noise.fbm(coord.x * mountainScale + 200, coord.y * mountainScale + 200, coord.z * mountainScale + 200, 3) * 0.5;
                    mountainsLayer[idx] = Math.max(0, Math.min(1, mountains + 0.5));
                    
                    const rivers = noise.fbm(coord.x * riverScale + 300, coord.y * riverScale + 300, coord.z * riverScale + 300, 2);
                    riversLayer[idx] = Math.max(0, Math.min(1, Math.abs(rivers)));
                    
                    const hills = noise.fbm(coord.x * hillScale + 400, coord.y * hillScale + 400, coord.z * hillScale + 400, 4) * 0.2;
                    hillsLayer[idx] = Math.max(0, Math.min(1, hills + 0.5));
                    
                    const details = noise.fbm(coord.x * detailScale + 500, coord.y * detailScale + 500, coord.z * detailScale + 500, 3) * 0.1;
                    detailsLayer[idx] = Math.max(0, Math.min(1, details + 0.5));
                    
                    const tectonics = noise.fbm(coord.x * tectonicScale + 700, coord.y * tectonicScale + 700, coord.z * tectonicScale + 700, 2);
                    tectonicsLayer[idx] = Math.max(0, Math.min(1, tectonics + 0.5));
                    
                    // Combine terrain layers
                    let height = continents * 0.35 + islands * 0.2 + mountains * 0.3 + hills * 0.1 + details * 0.05;
                    
                    // River carving
                    if (height > 0.25 && milesPerSide >= 10) {
                        const riverCarving = Math.abs(rivers);
                        if (riverCarving < 0.1) {
                            const riverDepth = (0.1 - riverCarving) * 0.3;
                            height -= riverDepth;
                        }
                    }
                    
                    // Enhanced mountain building
                    if (tectonics > 0.5 && height > 0.25) {
                        const mountainBoost = (tectonics - 0.5) * 1.5;
                        height += mountainBoost;
                    }
                    
                    if (tectonics > 0.75 && height > 0.4) {
                        const superPeaks = (tectonics - 0.75) * 2.0;
                        height += superPeaks;
                    }
                    
                    // Mountain ridge enhancement
                    const ridges = noise.fbm(coord.x * ridgeScale + 1100, coord.y * ridgeScale + 1100, coord.z * ridgeScale + 1100, 2);
                    if (ridges > 0.6 && height > 0.5) {
                        height += (ridges - 0.6) * 1.2;
                    }
                    
                    // Coastal erosion and beaches
                    if (milesPerSide >= 20) {
                        const coastal = noise.fbm(coord.x * coastalScale + 800, coord.y * coastalScale + 800, coord.z * coastalScale + 800, 2) * 0.05;
                        if (height > 0.15 && height < 0.4) {
                            height += coastal;
                        }
                    }
                    
                    height = Math.max(0, Math.min(1, height));
                    
                    // Quantize height to 10 discrete levels
                    let quantizedHeight;
                    if (height <= 0.3) {
                        quantizedHeight = Math.floor((height / 0.3) * 3) + 1;
                        quantizedHeight = Math.max(1, Math.min(3, quantizedHeight));
                    } else {
                        quantizedHeight = Math.floor(((height - 0.3) / 0.7) * 7) + 4;
                        quantizedHeight = Math.max(4, Math.min(10, quantizedHeight));
                        
                        // Minimize large sand areas - optimized coastal check
                        if (quantizedHeight === 4) {
                            let nearWater = false;
                            
                            // Efficient spiral search pattern
                            for (let r = 1; r <= checkRadius && !nearWater; r++) {
                                for (let angle = 0; angle < 8 && !nearWater; angle++) {
                                    const dx = Math.round(r * Math.cos(angle * Math.PI / 4));
                                    const dy = Math.round(r * Math.sin(angle * Math.PI / 4));
                                    
                                    const checkX = Math.max(0, Math.min(size-1, x + dx));
                                    const checkY = Math.max(0, Math.min(size-1, y + dy));
                                    
                                    if (checkX !== x || checkY !== y) {
                                        const checkU = checkX / (size - 1);
                                        const checkV = checkY / (size - 1);
                                        const checkCoords = getCubeCoords(face, checkU, checkV);
                                        
                                        // Quick height estimation using fewer octaves
                                        const checkContinents = noise.fbm(checkCoords.x * continentScale, checkCoords.y * continentScale, checkCoords.z * continentScale, 2) * 0.7;
                                        const checkIslands = noise.fbm(checkCoords.x * islandScale + 100, checkCoords.y * islandScale + 100, checkCoords.z * islandScale + 100, 2) * 0.4;
                                        
                                        let checkHeight = checkContinents * 0.6 + checkIslands * 0.4;
                                        checkHeight = Math.max(0, Math.min(1, checkHeight));
                                        
                                        if (checkHeight <= 0.3) {
                                            nearWater = true;
                                        }
                                    }
                                }
                            }
                            
                            if (!nearWater) {
                                quantizedHeight = 5;
                            }
                        }
                    }
                    
                    heightData[idx] = quantizedHeight / 10;
                }
            }
            
            // Post-process ocean for more dramatic depth variation
            enhanceOceanDepths(heightData, size);
            
            // Generate biomes in final pass
            for (let i = 0; i < size * size; i++) {
                const coord = coords[i];
                const finalHeight = Math.round(heightData[i] * 10);
                
                // Generate climate for biome
                let latitude = Math.abs(coord.y);
                let baseTemp = 1.0 - latitude * 0.8;
                const elevationCooling = Math.max(0, (finalHeight/10) - 0.3) * 1.0;
                const tempNoise = noise.fbm(coord.x * climateScale + 900, coord.y * climateScale + 900, coord.z * climateScale + 900, 3) * 0.3;
                const temperature = Math.max(0, Math.min(1, baseTemp - elevationCooling + tempNoise));
                
                const precipitation = noise.fbm(coord.x * precipScale + 1000, coord.y * precipScale + 1000, coord.z * precipScale + 1000, 3);
                const oceanInfluence = Math.max(0, 0.5 - Math.max(0, (finalHeight/10) - 0.2) * 2);
                const moisture = Math.max(0, Math.min(1, precipitation * 0.6 + oceanInfluence * 0.3));
                
                const biome = getBiome(finalHeight, temperature, moisture);
                
                const biomeIdx = i * 4;
                biomeData[biomeIdx] = biome[0];
                biomeData[biomeIdx + 1] = biome[1];
                biomeData[biomeIdx + 2] = biome[2];
                biomeData[biomeIdx + 3] = 255;
            }
            
            // Store layers
            layers.continents = continentsLayer;
            layers.islands = islandsLayer;
            layers.mountains = mountainsLayer;
            layers.rivers = riversLayer;
            layers.hills = hillsLayer;
            layers.details = detailsLayer;
            layers.tectonics = tectonicsLayer;
            
            return { heightData, biomeData, layers };
        }

        function render(canvas, heightData, biomeData, size, view) {
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(size, size);
            const data = imageData.data;
            
            if (view === 'heightmap') {
                // Height value remapping: 1-3→0, 4→1, 5→2, 6→3, 7→5, 8→8, 9→11, 10→15
                const heightMapping = {
                    1: 0, 2: 0, 3: 0,  // Ocean depths → 0
                    4: 1,              // Beach → 1
                    5: 2,              // Lowlands → 2
                    6: 3,              // Hills → 3
                    7: 5,              // Highlands → 5
                    8: 8,              // Mountains → 8
                    9: 11,             // High mountains → 11
                    10: 15             // Snow peaks → 15
                };
                
                for (let i = 0; i < heightData.length; i++) {
                    // Convert quantized height (0.1-1.0) back to discrete levels
                    const heightLevel = Math.round(heightData[i] * 10);
                    const remappedValue = heightMapping[heightLevel] || 0;
                    const colorValue = remappedValue * 8; // Height value * 8 for RGB
                    
                    data[i * 4] = colorValue;     // R
                    data[i * 4 + 1] = colorValue; // G
                    data[i * 4 + 2] = colorValue; // B
                    data[i * 4 + 3] = 255;       // A
                }
            } else {
                data.set(biomeData);
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        function randomSeed() {
            const seed = Math.random().toString(36).substr(2, 9);
            document.getElementById('seed').value = seed;
        }

        // Test edge continuity - verifies adjacent faces have matching values at boundaries
        function testEdgeContinuity(size, seed) {
            const noise = new Noise(seed);
            const faces = ['front', 'back', 'left', 'right', 'top', 'bottom'];
            const data = {};
            
            // Generate all faces
            faces.forEach(face => {
                data[face] = generateFace(face, size, noise);
            });
            
            let errors = 0;
            const tolerance = 0.001; // Small tolerance for floating point comparison
            
            // Check edge continuity between adjacent faces
            const adjacencyTests = [
                // Test front-right edge
                () => {
                    for (let i = 0; i < size; i++) {
                        const frontEdge = data.front.heightData[i * size + (size - 1)]; // Right edge of front
                        const rightEdge = data.right.heightData[i * size + 0]; // Left edge of right
                        if (Math.abs(frontEdge - rightEdge) > tolerance) {
                            console.log(`Front-Right edge mismatch at ${i}: ${frontEdge} vs ${rightEdge}`);
                            errors++;
                        }
                    }
                },
                // Test front-top edge  
                () => {
                    for (let i = 0; i < size; i++) {
                        const frontEdge = data.front.heightData[0 * size + i]; // Top edge of front
                        const topEdge = data.top.heightData[(size - 1) * size + i]; // Bottom edge of top
                        if (Math.abs(frontEdge - topEdge) > tolerance) {
                            console.log(`Front-Top edge mismatch at ${i}: ${frontEdge} vs ${topEdge}`);
                            errors++;
                        }
                    }
                },
                // Test right-top edge
                () => {
                    for (let i = 0; i < size; i++) {
                        const rightEdge = data.right.heightData[0 * size + i]; // Top edge of right
                        const topEdge = data.top.heightData[i * size + (size - 1)]; // Right edge of top
                        if (Math.abs(rightEdge - topEdge) > tolerance) {
                            console.log(`Right-Top edge mismatch at ${i}: ${rightEdge} vs ${topEdge}`);
                            errors++;
                        }
                    }
                }
            ];
            
            adjacencyTests.forEach(test => test());
            
            console.log(`Edge continuity test completed. Errors found: ${errors}`);
            return errors === 0;
        }

        function generate() {
            let size = parseInt(document.getElementById('size').value);
            
            // Validate size input - allow any positive integer
            if (isNaN(size) || size < 1) {
                size = 64;
                document.getElementById('size').value = 64;
            }
            
            const seedInput = document.getElementById('seed').value.trim();
            const seed = seedInput || Math.random().toString(36).substr(2, 9);
            
            document.getElementById('seed').value = seed;
            const noise = new Noise(seed);
            
            console.log(`Generating ${size}x${size} mile terrain with seed: ${seed}`);
            
            // Test edge continuity on a small sample for performance
            if (size <= 128) {
                console.log(`Testing edge continuity...`);
                testEdgeContinuity(Math.min(32, size), seed);
            } else {
                console.log(`Skipping edge continuity test for large size (${size}x${size})`);
            }
            
            const faces = ['front', 'back', 'left', 'right', 'top', 'bottom'];
            currentData = {};
            
            faces.forEach(face => {
                const canvas = document.getElementById(face);
                const data = generateFace(face, size, noise);
                currentData[face] = data;
                render(canvas, data.heightData, data.biomeData, size, currentView);
                
                // Store layers from front face for layer visualization
                if (face === 'front') {
                    currentLayers = data.layers;
                }
            });
            
            // Log scale information with expected feature counts
            console.log(`Generated enhanced terrain for ${size}x${size} square miles:`);
            console.log(`- Ocean depths: Deep ocean (1), Medium (2), Shallow 2-15mi from shore (3)`);
            console.log(`- Heights: Remapped values (Ocean:0, Beach:1, Lowlands:2, Hills:3, Highlands:5, Mountains:8, High:11, Snow:15)`);
            console.log(`- Colors: Exactly 10 unique biome colors with enhanced ocean depth variation`);
            console.log(`- Expected continents: ~${Math.floor(size/80)} (80 miles each)`);
            console.log(`- Expected islands: ~${Math.floor(size/20)} (20 miles each)`);
            console.log(`- Expected mountain ranges: ~${Math.floor(size/40)} (40 miles each)`);
            if (size >= 10) console.log(`- Rivers: ~4 miles wide`);
            if (size >= 20) console.log(`- Coastal features: ~6 mile detail`);
            console.log(`- Climate zones: ~100 mile scale`);
        }

        function switchView() {
            currentView = currentView === 'heightmap' ? 'biome' : 'heightmap';
            document.getElementById('viewLabel').textContent = `(${currentView === 'heightmap' ? 'Heightmap' : 'Biome'})`;
            
            if (currentData) {
                const size = parseInt(document.getElementById('size').value);
                Object.keys(currentData).forEach(face => {
                    const canvas = document.getElementById(face);
                    const data = currentData[face];
                    render(canvas, data.heightData, data.biomeData, size, currentView);
                });
            }
        }

        function downloadCubeNet() {
            if (!currentData) {
                alert('Please generate a map first!');
                return;
            }
            
            const size = parseInt(document.getElementById('size').value) || 128;
            const timestamp = new Date().toISOString().slice(0, 16).replace(/[:-]/g, '');
            const seedValue = document.getElementById('seed').value || 'random';
            const sizeValue = document.getElementById('size').value || '128';
            
            // Create combined canvas for cube net (4x3 grid)
            const combinedCanvas = document.createElement('canvas');
            const borderWidth = 2; // Match the red border width
            const faceSize = size;
            const totalWidth = (faceSize + borderWidth) * 4 + borderWidth;
            const totalHeight = (faceSize + borderWidth) * 3 + borderWidth;
            
            combinedCanvas.width = totalWidth;
            combinedCanvas.height = totalHeight;
            const ctx = combinedCanvas.getContext('2d');
            
            // Fill background with black
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, totalWidth, totalHeight);
            
            // Draw red grid lines
            ctx.strokeStyle = 'red';
            ctx.lineWidth = borderWidth;
            
            // Vertical lines
            for (let i = 0; i <= 4; i++) {
                const x = i * (faceSize + borderWidth) + borderWidth / 2;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, totalHeight);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let i = 0; i <= 3; i++) {
                const y = i * (faceSize + borderWidth) + borderWidth / 2;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(totalWidth, y);
                ctx.stroke();
            }
            
            // Define face positions in the cube net (4x3 grid)
            const facePositions = {
                'top': { x: 1, y: 0 },
                'left': { x: 0, y: 1 },
                'front': { x: 1, y: 1 },
                'right': { x: 2, y: 1 },
                'back': { x: 3, y: 1 },
                'bottom': { x: 1, y: 2 }
            };
            
            // Draw each face at its position
            Object.keys(facePositions).forEach(face => {
                const canvas = document.getElementById(face);
                if (canvas) {
                    const pos = facePositions[face];
                    const x = pos.x * (faceSize + borderWidth) + borderWidth;
                    const y = pos.y * (faceSize + borderWidth) + borderWidth;
                    
                    ctx.drawImage(canvas, x, y, faceSize, faceSize);
                }
            });
            
            // Download the combined image
            try {
                const link = document.createElement('a');
                link.style.display = 'none';
                link.download = `cubenet_${currentView}_${sizeValue}mi_${seedValue}_${timestamp}.png`;
                link.href = combinedCanvas.toDataURL();
                link.click();
                
                console.log(`Downloaded cube net (${currentView} view): ${totalWidth}x${totalHeight}px`);
            } catch (error) {
                console.error('Failed to download cube net:', error);
            }
        }

        function downloadAll() {
            console.log(`Initiated download of 6cube faces (${currentView} view)`);
            if (!currentData) {
                alert('Please generate a map first!');
                console.log('No map to download');
                return;
            }

            const timestamp = new Date().toISOString().slice(0, 16).replace(/[:-]/g, '');
            const seedValue = document.getElementById('seed').value || 'random';
            const sizeValue = document.getElementById('size').value || '128';
            
            Object.keys(currentData).forEach(face => {
                const canvas = document.getElementById(face);
                const link = document.createElement('a');
                link.download = `${face}_${currentView}_${sizeValue}mi_${seedValue}_${timestamp}.png`;
                link.href = canvas.toDataURL();
                link.click();
            });
        }

        // Generate initial map with test seed to verify edge continuity  
        document.getElementById('size').value = '80';
        document.getElementById('seed').value = 'test123';
        generate();
    </script>
</body>
</html>
