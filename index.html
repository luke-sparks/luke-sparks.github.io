<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cube Map Generator</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .controls { margin-bottom: 20px; }
        .controls input, button { margin: 5px; padding: 5px; }
        .cube-grid { 
            display: grid; 
            grid-template-columns: repeat(4, 80px); 
            grid-template-rows: repeat(3, 80px); 
            gap: 1px; 
        }
        .face canvas { width: 100%; height: 100%; border: 1px solid #999; }
    </style>
</head>
<body>
    <div class="controls">
        <label>Size: <input type="number" id="size" placeholder="128" min="1" max="10000" style="width: 100px;"> miles per side</label>
        <label>Seed: <input type="text" id="seed" placeholder="Random"></label>
        <button onclick="randomSeed()">Random Seed</button>
        <button onclick="generate()">Generate</button>
        <button onclick="switchView()">Toggle View</button>
        <button onclick="toggleLayers()">Show Layers</button>
        <button onclick="downloadAll()">Download All</button>
        <span id="viewLabel">(Heightmap)</span>
    </div>
    
    <div style="display: flex; gap: 20px;">
        <div>
            <h4>Cube Net</h4>
            <div class="cube-grid">
                <!-- Cross layout: top, left-front-right-back, bottom -->
                <div></div><div class="face"><canvas id="top"></canvas></div><div></div><div></div>
                <div class="face"><canvas id="left"></canvas></div><div class="face"><canvas id="front"></canvas></div><div class="face"><canvas id="right"></canvas></div><div class="face"><canvas id="back"></canvas></div>
                <div></div><div class="face"><canvas id="bottom"></canvas></div><div></div><div></div>
            </div>
            <div style="font-size: 12px; margin-top: 10px; color: #666;">
                Realistic scaling: Islands ~20mi, Continents ~80mi, Rivers ~4mi wide.<br>
                Heightmap values: Ocean(0), Beach(1), Lowlands(2), Hills(3), Highlands(5), Mountains(8), High peaks(11), Snow caps(15).<br>
                Edge continuity is mathematically guaranteed and tested on generation.
            </div>
        </div>
    </div>

    <div id="layersSection" style="display: none; margin-top: 30px;">
        <h4>Terrain Generation Layers (Front Face)</h4>
        <div style="display: grid; grid-template-columns: repeat(4, 150px); gap: 15px; margin-top: 15px;">
            <div style="text-align: center;">
                <div style="font-size: 12px; margin-bottom: 5px; font-weight: bold;">continents</div>
                <canvas id="layer-continents" width="120" height="120" style="border: 1px solid #999;"></canvas>
                <div style="font-size: 10px; color: #666; margin-top: 2px;">~80 mile diameter</div>
            </div>
            <div style="text-align: center;">
                <div style="font-size: 12px; margin-bottom: 5px; font-weight: bold;">islands</div>
                <canvas id="layer-islands" width="120" height="120" style="border: 1px solid #999;"></canvas>
                <div style="font-size: 10px; color: #666; margin-top: 2px;">~20 mile diameter</div>
            </div>
            <div style="text-align: center;">
                <div style="font-size: 12px; margin-bottom: 5px; font-weight: bold;">mountains</div>
                <canvas id="layer-mountains" width="120" height="120" style="border: 1px solid #999;"></canvas>
                <div style="font-size: 10px; color: #666; margin-top: 2px;">~40 mile width</div>
            </div>
            <div style="text-align: center;">
                <div style="font-size: 12px; margin-bottom: 5px; font-weight: bold;">rivers</div>
                <canvas id="layer-rivers" width="120" height="120" style="border: 1px solid #999;"></canvas>
                <div style="font-size: 10px; color: #666; margin-top: 2px;">~4 mile width</div>
            </div>
            <div style="text-align: center;">
                <div style="font-size: 12px; margin-bottom: 5px; font-weight: bold;">hills</div>
                <canvas id="layer-hills" width="120" height="120" style="border: 1px solid #999;"></canvas>
                <div style="font-size: 10px; color: #666; margin-top: 2px;">~8 mile features</div>
            </div>
            <div style="text-align: center;">
                <div style="font-size: 12px; margin-bottom: 5px; font-weight: bold;">details</div>
                <canvas id="layer-details" width="120" height="120" style="border: 1px solid #999;"></canvas>
                <div style="font-size: 10px; color: #666; margin-top: 2px;">~2 mile features</div>
            </div>
            <div style="text-align: center;">
                <div style="font-size: 12px; margin-bottom: 5px; font-weight: bold;">tectonics</div>
                <canvas id="layer-tectonics" width="120" height="120" style="border: 1px solid #999;"></canvas>
                <div style="font-size: 10px; color: #666; margin-top: 2px;">~60 mile features</div>
            </div>
        </div>
        <div style="margin-top: 15px; font-size: 12px; color: #666;">
            Each layer contributes to final terrain. Heightmap uses remapped values: Ocean(0), Beach(1), Lowlands(2), Hills(3), Highlands(5), Mountains(8), High peaks(11), Snow caps(15).
        </div>
    </div>

    <script>
        let currentView = 'heightmap';
        let currentData = null;
        let currentLayers = null;
        let layersVisible = false;

        class Noise {
            constructor(seed) {
                this.seed = this.hashSeed(seed || Math.random().toString());
            }
            
            hashSeed(s) {
                let h = 0;
                for (let i = 0; i < s.length; i++) {
                    h = ((h << 5) - h + s.charCodeAt(i)) | 0;
                }
                // Ensure seed has strong impact by using multiple hash iterations
                h = h * 1013904223 + 1664525;
                h = h * 1664525 + 1013904223;
                return Math.abs(h) / 2147483648;
            }
            
            hash(x, y, z) {
                // Strong hash function that amplifies seed differences
                let h = this.seed * 999999999 + x * 374761393 + y * 668265263 + z * 1274126177;
                h = (h ^ (h >>> 13)) * 1274126177;
                h = (h ^ (h >>> 16)) * 1974126343;
                h = (h ^ (h >>> 7)) * 1374761393;
                return (h ^ (h >>> 14)) / 4294967296 + 0.5;
            }
            
            smoothstep(t) { return t * t * (3 - 2 * t); }
            
            noise3D(x, y, z) {
                const ix = Math.floor(x), iy = Math.floor(y), iz = Math.floor(z);
                const fx = x - ix, fy = y - iy, fz = z - iz;
                const sx = this.smoothstep(fx), sy = this.smoothstep(fy), sz = this.smoothstep(fz);
                
                // Get hash values for cube corners
                const c000 = this.hash(ix, iy, iz);
                const c001 = this.hash(ix, iy, iz+1);
                const c010 = this.hash(ix, iy+1, iz);
                const c011 = this.hash(ix, iy+1, iz+1);
                const c100 = this.hash(ix+1, iy, iz);
                const c101 = this.hash(ix+1, iy, iz+1);
                const c110 = this.hash(ix+1, iy+1, iz);
                const c111 = this.hash(ix+1, iy+1, iz+1);
                
                // Trilinear interpolation
                const c00 = c000*(1-sx) + c100*sx;
                const c01 = c001*(1-sx) + c101*sx;
                const c10 = c010*(1-sx) + c110*sx;
                const c11 = c011*(1-sx) + c111*sx;
                
                const c0 = c00*(1-sy) + c10*sy;
                const c1 = c01*(1-sy) + c11*sy;
                
                return c0*(1-sz) + c1*sz;
            }
            
            fbm(x, y, z, octaves = 6) {
                let value = 0, amp = 1, freq = 1, maxValue = 0;
                for (let i = 0; i < octaves; i++) {
                    value += this.noise3D(x * freq, y * freq, z * freq) * amp;
                    maxValue += amp;
                    amp *= 0.5;
                    freq *= 2;
                }
                return value / maxValue;
            }
        }

        function getCubeCoords(face, u, v) {
            // Convert texture coordinates [0,1] to cube coordinates
            // Using standard cube mapping with perfect edge continuity
            const s = u * 2 - 1;  // [-1, 1]
            const t = v * 2 - 1;  // [-1, 1]
            
            let x, y, z;
            
            // Standard OpenGL cube mapping convention for perfect edge alignment
            switch(face) {
                case 'front':  // +Z face
                    x = s; y = -t; z = 1;
                    break;
                case 'back':   // -Z face  
                    x = -s; y = -t; z = -1;
                    break;
                case 'right':  // +X face
                    x = 1; y = -t; z = -s;
                    break;
                case 'left':   // -X face
                    x = -1; y = -t; z = s;
                    break;
                case 'top':    // +Y face
                    x = s; y = 1; z = t;
                    break;
                case 'bottom': // -Y face
                    x = s; y = -1; z = -t;
                    break;
            }
            
            // Normalize to unit sphere for seamless noise sampling across edges
            const len = Math.sqrt(x*x + y*y + z*z);
            return { x: x/len, y: y/len, z: z/len };
        }

        function getBiome(heightLevel, temperature, moisture) {
            // Exactly 10 colors based on height levels 1-10
            // Levels 1-3: Ocean depths, Levels 4-10: Land elevations
            
            const colors = [
                null, // Index 0 unused
                [15, 30, 80],   // Level 1: Deep ocean (darkest blue)
                [25, 50, 120],  // Level 2: Medium ocean  
                [40, 80, 160],  // Level 3: Shallow ocean (lightest blue)
                [220, 200, 160], // Level 4: Beach/coastal (sandy)
                [120, 180, 80],  // Level 5: Lowlands/plains (green)
                [100, 150, 70],  // Level 6: Hills (darker green)
                [140, 120, 80],  // Level 7: Highlands (brown-green)
                [160, 140, 100], // Level 8: Mountains (brown)
                [180, 160, 140], // Level 9: High mountains (gray-brown)
                [240, 240, 250]  // Level 10: Snow peaks (white)
            ];
            
            // Return the exact color for this height level
            return colors[heightLevel] || [0, 0, 0];
        }

        function generateFace(face, size, noise) {
            const heightData = new Float32Array(size * size);
            const biomeData = new Uint8ClampedArray(size * size * 4);
            
            // Store individual layers for debugging/visualization
            const layers = {};
            
            // Scale-aware terrain generation (1 pixel = 1 mile)
            const milesPerSide = size;
            
            // Calculate feature scales based on desired real-world sizes
            // Larger maps will have MORE features, smaller maps will have FEWER features
            const continentScale = milesPerSide / 80;    // Continents ~80 miles diameter
            const islandScale = milesPerSide / 20;       // Islands ~20 miles diameter  
            const mountainScale = milesPerSide / 40;     // Mountain ranges ~40 miles across
            const riverScale = milesPerSide / 4;         // Rivers ~4 miles wide
            const hillScale = milesPerSide / 8;          // Hills ~8 miles across
            const detailScale = milesPerSide / 2;        // Fine details ~2 miles
            
            // Pre-calculate all layers
            const continentsLayer = new Float32Array(size * size);
            const islandsLayer = new Float32Array(size * size);
            const mountainsLayer = new Float32Array(size * size);
            const riversLayer = new Float32Array(size * size);
            const hillsLayer = new Float32Array(size * size);
            const detailsLayer = new Float32Array(size * size);
            const tectonicsLayer = new Float32Array(size * size);
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const u = x / (size - 1);
                    const v = y / (size - 1);
                    
                    // Get 3D coordinates ensuring perfect edge continuity
                    const coords = getCubeCoords(face, u, v);
                    const idx = y * size + x;
                    
                    // Generate all layers
                    
                    // 1. Continental masses (~80 mile diameter)
                    const continents = noise.fbm(
                        coords.x * continentScale, 
                        coords.y * continentScale, 
                        coords.z * continentScale, 
                        3
                    ) * 0.7;
                    continentsLayer[idx] = Math.max(0, Math.min(1, continents + 0.5));
                    
                    // 2. Island chains (~20 mile diameter)
                    const islands = noise.fbm(
                        coords.x * islandScale + 100, 
                        coords.y * islandScale + 100, 
                        coords.z * islandScale + 100, 
                        4
                    ) * 0.4;
                    islandsLayer[idx] = Math.max(0, Math.min(1, islands + 0.5));
                    
                    // 3. Mountain ranges (~40 mile width)
                    const mountains = noise.fbm(
                        coords.x * mountainScale + 200, 
                        coords.y * mountainScale + 200, 
                        coords.z * mountainScale + 200, 
                        3
                    ) * 0.5;
                    mountainsLayer[idx] = Math.max(0, Math.min(1, mountains + 0.5));
                    
                    // 4. River valleys and erosion (~4 mile width)
                    const rivers = noise.fbm(
                        coords.x * riverScale + 300, 
                        coords.y * riverScale + 300, 
                        coords.z * riverScale + 300, 
                        2
                    );
                    riversLayer[idx] = Math.max(0, Math.min(1, Math.abs(rivers)));
                    
                    // 5. Hills and local terrain (~8 mile features)
                    const hills = noise.fbm(
                        coords.x * hillScale + 400, 
                        coords.y * hillScale + 400, 
                        coords.z * hillScale + 400, 
                        4
                    ) * 0.2;
                    hillsLayer[idx] = Math.max(0, Math.min(1, hills + 0.5));
                    
                    // 6. Fine surface details (~2 mile features)
                    const details = noise.fbm(
                        coords.x * detailScale + 500, 
                        coords.y * detailScale + 500, 
                        coords.z * detailScale + 500, 
                        3
                    ) * 0.1;
                    detailsLayer[idx] = Math.max(0, Math.min(1, details + 0.5));
                    
                    // Tectonic activity
                    const tectonicScale = milesPerSide / 60; // Tectonic features ~60 miles
                    const tectonics = noise.fbm(
                        coords.x * tectonicScale + 700, 
                        coords.y * tectonicScale + 700, 
                        coords.z * tectonicScale + 700, 
                        2
                    );
                    tectonicsLayer[idx] = Math.max(0, Math.min(1, tectonics + 0.5));
                    
                    // Combine terrain layers (increased mountain contribution)
                    let height = continents * 0.35 + islands * 0.2 + mountains * 0.3 + hills * 0.1 + details * 0.05;
                    
                    // River carving (creates river valleys ~4 miles wide)
                    if (height > 0.25 && milesPerSide >= 10) {
                        const riverCarving = Math.abs(rivers);
                        if (riverCarving < 0.1) {
                            // Create river valley
                            const riverDepth = (0.1 - riverCarving) * 0.3;
                            height -= riverDepth;
                        }
                    }
                    
                    // Enhanced mountain building (more aggressive peak creation)
                    if (tectonics > 0.5 && height > 0.25) {
                        // Create mountain peaks - much more aggressive
                        const mountainBoost = (tectonics - 0.5) * 1.5; // Increased from 0.8
                        height += mountainBoost;
                    }
                    
                    // Additional peak formation for very high tectonic activity
                    if (tectonics > 0.75 && height > 0.4) {
                        const superPeaks = (tectonics - 0.75) * 2.0; // Extra boost for highest peaks
                        height += superPeaks;
                    }
                    
                    // Mountain ridge enhancement (creates connected mountain ranges)
                    const ridgeScale = milesPerSide / 30; // Ridge features ~30 miles
                    const ridges = noise.fbm(
                        coords.x * ridgeScale + 1100, 
                        coords.y * ridgeScale + 1100, 
                        coords.z * ridgeScale + 1100, 
                        2
                    );
                    
                    if (ridges > 0.6 && height > 0.5) {
                        height += (ridges - 0.6) * 1.2; // Add ridge peaks
                    }
                    
                    // Coastal erosion and beaches (only for maps with sufficient detail)
                    if (milesPerSide >= 20) {
                        const coastalScale = milesPerSide / 6; // Coastal features ~6 miles
                        const coastal = noise.fbm(
                            coords.x * coastalScale + 800, 
                            coords.y * coastalScale + 800, 
                            coords.z * coastalScale + 800, 
                            2
                        ) * 0.05;
                        
                        // Add coastal variation
                        if (height > 0.15 && height < 0.4) {
                            height += coastal;
                        }
                    }
                    
                    // Ensure height is in valid range
                    height = Math.max(0, Math.min(1, height));
                    
                    // Quantize height to 10 discrete levels (1-10)
                    // 0.0-0.3 -> levels 1-3 (ocean depths)
                    // 0.3-1.0 -> levels 4-10 (land elevations)
                    let quantizedHeight;
                    if (height <= 0.3) {
                        // Ocean: map 0-0.3 to levels 1-3
                        quantizedHeight = Math.floor((height / 0.3) * 3) + 1;
                        quantizedHeight = Math.max(1, Math.min(3, quantizedHeight));
                    } else {
                        // Land: map 0.3-1.0 to levels 4-10
                        quantizedHeight = Math.floor(((height - 0.3) / 0.7) * 7) + 4;
                        quantizedHeight = Math.max(4, Math.min(10, quantizedHeight));
                        
                        // Minimize large sand areas - convert level 4 to level 5 if not near water
                        if (quantizedHeight === 4) {
                            // Check if this pixel is actually coastal (near lower elevation)
                            let nearWater = false;
                            const checkRadius = Math.max(1, Math.floor(size / 100)); // Adaptive radius
                            
                            for (let dy = -checkRadius; dy <= checkRadius && !nearWater; dy++) {
                                for (let dx = -checkRadius; dx <= checkRadius && !nearWater; dx++) {
                                    const checkX = Math.max(0, Math.min(size-1, x + dx));
                                    const checkY = Math.max(0, Math.min(size-1, y + dy));
                                    const checkU = checkX / (size - 1);
                                    const checkV = checkY / (size - 1);
                                    const checkCoords = getCubeCoords(face, checkU, checkV);
                                    
                                    // Sample height at nearby location
                                    const checkContinents = noise.fbm(checkCoords.x * continentScale, checkCoords.y * continentScale, checkCoords.z * continentScale, 3) * 0.7;
                                    const checkIslands = noise.fbm(checkCoords.x * islandScale + 100, checkCoords.y * islandScale + 100, checkCoords.z * islandScale + 100, 4) * 0.4;
                                    const checkMountains = noise.fbm(checkCoords.x * mountainScale + 200, checkCoords.y * mountainScale + 200, checkCoords.z * mountainScale + 200, 3) * 0.5;
                                    const checkHills = noise.fbm(checkCoords.x * hillScale + 400, checkCoords.y * hillScale + 400, checkCoords.z * hillScale + 400, 4) * 0.2;
                                    const checkDetails = noise.fbm(checkCoords.x * detailScale + 500, checkCoords.y * detailScale + 500, checkCoords.z * detailScale + 500, 3) * 0.1;
                                    
                                    let checkHeight = checkContinents * 0.35 + checkIslands * 0.2 + checkMountains * 0.3 + checkHills * 0.1 + checkDetails * 0.05;
                                    checkHeight = Math.max(0, Math.min(1, checkHeight));
                                    
                                    if (checkHeight <= 0.3) {
                                        nearWater = true; // Found water nearby
                                    }
                                }
                            }
                            
                            // If not near water, convert sand to grassland
                            if (!nearWater) {
                                quantizedHeight = 5; // Convert to lowlands/plains
                            }
                        }
                    }
                    
                    heightData[idx] = quantizedHeight / 10; // Store as 0.1-1.0 for compatibility
                    
                    // Generate climate for biome (use original continuous height for climate calc)
                    
                    // Latitude-based temperature (poles are colder)
                    let latitude = Math.abs(coords.y);
                    let baseTemp = 1.0 - latitude * 0.8;
                    
                    // Elevation cooling (mountains are colder)
                    const elevationCooling = Math.max(0, height - 0.3) * 1.0;
                    
                    // Climate variation
                    const climateScale = milesPerSide / 100; // Climate zones ~100 miles
                    const tempNoise = noise.fbm(
                        coords.x * climateScale + 900, 
                        coords.y * climateScale + 900, 
                        coords.z * climateScale + 900, 
                        3
                    ) * 0.3;
                    
                    const temperature = Math.max(0, Math.min(1, baseTemp - elevationCooling + tempNoise));
                    
                    // Precipitation patterns
                    const precipScale = milesPerSide / 80; // Weather systems ~80 miles
                    const precipitation = noise.fbm(
                        coords.x * precipScale + 1000, 
                        coords.y * precipScale + 1000, 
                        coords.z * precipScale + 1000, 
                        3
                    );
                    
                    // Ocean effect on moisture
                    const oceanInfluence = Math.max(0, 0.5 - Math.max(0, height - 0.2) * 2);
                    const moisture = Math.max(0, Math.min(1, precipitation * 0.6 + oceanInfluence * 0.3));
                    
                    const biome = getBiome(quantizedHeight, temperature, moisture);
                    
                    const biomeIdx = idx * 4;
                    biomeData[biomeIdx] = biome[0];
                    biomeData[biomeIdx + 1] = biome[1];
                    biomeData[biomeIdx + 2] = biome[2];
                    biomeData[biomeIdx + 3] = 255;
                }
            }
            
            // Store layers
            layers.continents = continentsLayer;
            layers.islands = islandsLayer;
            layers.mountains = mountainsLayer;
            layers.rivers = riversLayer;
            layers.hills = hillsLayer;
            layers.details = detailsLayer;
            layers.tectonics = tectonicsLayer;
            
            return { heightData, biomeData, layers };
        }

        function render(canvas, heightData, biomeData, size, view) {
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(size, size);
            const data = imageData.data;
            
            if (view === 'heightmap') {
                // Height value remapping: 1-3→0, 4→1, 5→2, 6→3, 7→5, 8→8, 9→11, 10→15
                const heightMapping = {
                    1: 0, 2: 0, 3: 0,  // Ocean depths → 0
                    4: 1,              // Beach → 1
                    5: 2,              // Lowlands → 2
                    6: 3,              // Hills → 3
                    7: 5,              // Highlands → 5
                    8: 8,              // Mountains → 8
                    9: 11,             // High mountains → 11
                    10: 15             // Snow peaks → 15
                };
                
                for (let i = 0; i < heightData.length; i++) {
                    // Convert quantized height (0.1-1.0) back to discrete levels
                    const heightLevel = Math.round(heightData[i] * 10);
                    const remappedValue = heightMapping[heightLevel] || 0;
                    const colorValue = remappedValue * 8; // Height value * 8 for RGB
                    
                    data[i * 4] = colorValue;     // R
                    data[i * 4 + 1] = colorValue; // G
                    data[i * 4 + 2] = colorValue; // B
                    data[i * 4 + 3] = 255;       // A
                }
            } else {
                data.set(biomeData);
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        function toggleLayers() {
            layersVisible = !layersVisible;
            const layersSection = document.getElementById('layersSection');
            
            if (layersVisible) {
                layersSection.style.display = 'block';
                if (currentLayers) {
                    renderLayers(currentLayers);
                }
            } else {
                layersSection.style.display = 'none';
            }
        }

        function renderLayers(layers) {
            const layerNames = ['continents', 'islands', 'mountains', 'rivers', 'hills', 'details', 'tectonics'];
            
            layerNames.forEach(layerName => {
                const canvas = document.getElementById(`layer-${layerName}`);
                const layerData = layers[layerName];
                
                if (canvas && layerData) {
                    const size = Math.sqrt(layerData.length);
                    canvas.width = size;
                    canvas.height = size;
                    
                    const ctx = canvas.getContext('2d');
                    const imageData = ctx.createImageData(size, size);
                    const data = imageData.data;
                    
                    // Render as grayscale
                    for (let i = 0; i < layerData.length; i++) {
                        const val = Math.floor(layerData[i] * 255);
                        data[i * 4] = val;
                        data[i * 4 + 1] = val;
                        data[i * 4 + 2] = val;
                        data[i * 4 + 3] = 255;
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                }
            });
        }

        function randomSeed() {
            const seed = Math.random().toString(36).substr(2, 9);
            document.getElementById('seed').value = seed;
        }

        // Test edge continuity - verifies adjacent faces have matching values at boundaries
        function testEdgeContinuity(size, seed) {
            const noise = new Noise(seed);
            const faces = ['front', 'back', 'left', 'right', 'top', 'bottom'];
            const data = {};
            
            // Generate all faces
            faces.forEach(face => {
                data[face] = generateFace(face, size, noise);
            });
            
            let errors = 0;
            const tolerance = 0.001; // Small tolerance for floating point comparison
            
            // Check edge continuity between adjacent faces
            const adjacencyTests = [
                // Test front-right edge
                () => {
                    for (let i = 0; i < size; i++) {
                        const frontEdge = data.front.heightData[i * size + (size - 1)]; // Right edge of front
                        const rightEdge = data.right.heightData[i * size + 0]; // Left edge of right
                        if (Math.abs(frontEdge - rightEdge) > tolerance) {
                            console.log(`Front-Right edge mismatch at ${i}: ${frontEdge} vs ${rightEdge}`);
                            errors++;
                        }
                    }
                },
                // Test front-top edge  
                () => {
                    for (let i = 0; i < size; i++) {
                        const frontEdge = data.front.heightData[0 * size + i]; // Top edge of front
                        const topEdge = data.top.heightData[(size - 1) * size + i]; // Bottom edge of top
                        if (Math.abs(frontEdge - topEdge) > tolerance) {
                            console.log(`Front-Top edge mismatch at ${i}: ${frontEdge} vs ${topEdge}`);
                            errors++;
                        }
                    }
                },
                // Test right-top edge
                () => {
                    for (let i = 0; i < size; i++) {
                        const rightEdge = data.right.heightData[0 * size + i]; // Top edge of right
                        const topEdge = data.top.heightData[i * size + (size - 1)]; // Right edge of top
                        if (Math.abs(rightEdge - topEdge) > tolerance) {
                            console.log(`Right-Top edge mismatch at ${i}: ${rightEdge} vs ${topEdge}`);
                            errors++;
                        }
                    }
                }
            ];
            
            adjacencyTests.forEach(test => test());
            
            console.log(`Edge continuity test completed. Errors found: ${errors}`);
            return errors === 0;
        }

        function generate() {
            let size = parseInt(document.getElementById('size').value);
            
            // Validate size input - allow any positive integer
            if (isNaN(size) || size < 1) {
                size = 64;
                document.getElementById('size').value = 64;
            }
            
            const seedInput = document.getElementById('seed').value.trim();
            const seed = seedInput || Math.random().toString(36).substr(2, 9);
            
            document.getElementById('seed').value = seed;
            const noise = new Noise(seed);
            
            console.log(`Generating ${size}x${size} mile terrain with seed: ${seed}`);
            
            // Test edge continuity on a small sample for performance
            if (size <= 128) {
                console.log(`Testing edge continuity...`);
                testEdgeContinuity(Math.min(32, size), seed);
            } else {
                console.log(`Skipping edge continuity test for large size (${size}x${size})`);
            }
            
            const faces = ['front', 'back', 'left', 'right', 'top', 'bottom'];
            currentData = {};
            
            faces.forEach(face => {
                const canvas = document.getElementById(face);
                const data = generateFace(face, size, noise);
                currentData[face] = data;
                render(canvas, data.heightData, data.biomeData, size, currentView);
                
                // Store layers from front face for layer visualization
                if (face === 'front') {
                    currentLayers = data.layers;
                }
            });
            
            // Update layer display if visible
            if (layersVisible && currentLayers) {
                renderLayers(currentLayers);
            }
            
            // Log scale information with expected feature counts
            console.log(`Generated quantized terrain for ${size}x${size} square miles:`);
            console.log(`- Heights: Remapped values (Ocean:0, Beach:1, Lowlands:2, Hills:3, Highlands:5, Mountains:8, High:11, Snow:15)`);
            console.log(`- Colors: Exactly 10 unique biome colors`);
            console.log(`- Expected continents: ~${Math.floor(size/80)} (80 miles each)`);
            console.log(`- Expected islands: ~${Math.floor(size/20)} (20 miles each)`);
            console.log(`- Expected mountain ranges: ~${Math.floor(size/40)} (40 miles each)`);
            if (size >= 10) console.log(`- Rivers: ~4 miles wide`);
            if (size >= 20) console.log(`- Coastal features: ~6 mile detail`);
            console.log(`- Climate zones: ~100 mile scale`);
        }

        function switchView() {
            currentView = currentView === 'heightmap' ? 'biome' : 'heightmap';
            document.getElementById('viewLabel').textContent = `(${currentView === 'heightmap' ? 'Heightmap' : 'Biome'})`;
            
            if (currentData) {
                const size = parseInt(document.getElementById('size').value);
                Object.keys(currentData).forEach(face => {
                    const canvas = document.getElementById(face);
                    const data = currentData[face];
                    render(canvas, data.heightData, data.biomeData, size, currentView);
                });
            }
        }

        function downloadAll() {
            console.log(`Initiated download of 6cube faces (${currentView} view)`);
            if (!currentData) {
                alert('Please generate a map first!');
                console.log('No map to download');
                return;
            }

            const timestamp = new Date().toISOString().slice(0, 16).replace(/[:-]/g, '');
            const seedValue = document.getElementById('seed').value || 'random';
            const sizeValue = document.getElementById('size').value || '128';
            
            Object.keys(currentData).forEach(face => {
                const canvas = document.getElementById(face);
                const link = document.createElement('a');
                // link.download = `${face}_${currentView}.png`;
                link.download = `${face}_${currentView}_${sizeValue}mi_${seedValue}_${timestamp}.png`;
                link.href = canvas.toDataURL();
                link.click();
            });
        }

        // Generate initial map with test seed to verify edge continuity  
        document.getElementById('size').value = '80';
        document.getElementById('seed').value = 'test123';
        generate();
    </script>
</body>
</html>
